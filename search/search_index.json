{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NATS Connect Opts","text":"<p>This is not an official NATS project</p> <p>This is a personal project and is not endorsed by the NATS.io community. It is not guaranteed to be maintained or supported.</p> <p>This is an experimental project</p> <p>This project is a prototype and should not be used for anything serious. It is not tested, nor is it guaranteed to be correct.</p>"},{"location":"#references","title":"References","text":"<ul> <li>The test fixture from nats-py.</li> </ul>"},{"location":"#how-to-install","title":"How to install","text":"pip install git+https://github.com/charbonnierg/nats-test-server.git"},{"location":"#example-usage","title":"Example usage","text":"examples/minimal.py<pre><code>from __future__ import annotations\nfrom typing import Iterator\n\nimport pytest\n\nfrom nats_contrib.test_server import NATSD\nfrom nats.aio.client import Client\n\n\n@pytest.fixture\ndef nats_server() -&gt; Iterator[NATSD]:\n    with NATSD(\n        port=4222,\n        address=\"localhost\",\n        client_advertise=\"localhost:4222\",\n        server_name=\"test-server-01\",\n        server_tags={\"region\": \"test01\"},\n        debug=True,\n        trace=True,\n        trace_verbose=False,\n        http_port=8222,\n        websocket_listen_address=\"localhost\",\n        websocket_listen_port=10080,\n        leafnodes_listen_port=7422,\n        pid_file=\"server/nats-server.pid\",\n        ports_file_dir=\"server\",\n    ) as server:\n        yield server\n\n\n@pytest.mark.asyncio\nasync def test_something(nats_server: NATSD) -&gt; None:\n    \"\"\"You can use nats_server fixture in your tests.\"\"\"\n    # Do something with NATS server\n    assert nats_server.is_alive()\n    # Create a client\n    client = Client()\n    # Connect to the server\n    await client.connect(\"nats://localhost:4222\")\n    # Do something with the client\n    async with client:\n        await client.publish(\"foo\")\n</code></pre> <p>Run the tests using <code>pytest</code> with the <code>-s</code> option to capture the standard output and standard error:</p> pytest examples/ -s========================== test session starts ==========================platform linux -- Python 3.10.12, pytest-8.0.1, pluggy-1.4.0rootdir: ~/github/charbonats/nats-test-serverconfigfile: setup.cfgplugins: cov-4.1.0, asyncio-0.23.5asyncio: mode=strictcollected 1 item                                                        examples/test_minimal.py [DEBUG] Using nats-server executable at /usr/local/bin/nats-server[DEBUG] Server listening on port 4222 started.[DEBUG] Waiting for server listening on port 4222 to be up.[191036] 2024/02/21 08:05:24.735483 [INF] Starting nats-server[191036] 2024/02/21 08:05:24.735746 [INF]   Version:  2.10.10[191036] 2024/02/21 08:05:24.735755 [INF]   Git:      [983a1d2][191036] 2024/02/21 08:05:24.735764 [DBG]   Go build: go1.21.6[191036] 2024/02/21 08:05:24.735773 [INF]   Name:     test-server-01[191036] 2024/02/21 08:05:24.735779 [INF]   ID:       NDW35OXDBEEFAAF5NZGU56WU3K5KXAGI4RNHDF6L5ZVDXIA4UON76UQX[191036] 2024/02/21 08:05:24.735828 [INF] Using configuration file: /tmp/tmprm9ln40r/nats.conf[191036] 2024/02/21 08:05:24.736046 [DBG] Created system account: \"$SYS\"[191036] 2024/02/21 08:05:24.737235 [INF] Listening for websocket clients on ws://localhost:10080[191036] 2024/02/21 08:05:24.737437 [WRN] Websocket not configured with TLS. DO NOT USE IN PRODUCTION![191036] 2024/02/21 08:05:24.737653 [INF] Listening for leafnode connections on 0.0.0.0:7422[191036] 2024/02/21 08:05:24.737911 [DBG] Get non local IPs for \"0.0.0.0\"[191036] 2024/02/21 08:05:24.738215 [DBG]   ip=172.31.93.60[191036] 2024/02/21 08:05:24.738282 [DBG]   ip=172.17.0.1[191036] 2024/02/21 08:05:24.739004 [INF] Listening for client connections on localhost:4222[191036] 2024/02/21 08:05:24.739132 [INF] Server is ready[191036] 2024/02/21 08:05:24.739986 [DBG] maxprocs: Leaving GOMAXPROCS=4: CPU quota undefined[DEBUG] Server listening on port 4222 is up.[191036] 2024/02/21 08:05:24.832027 [DBG] 127.0.0.1:51680 - cid:5 - Client connection created[191036] 2024/02/21 08:05:24.833198 [DBG] 127.0.0.1:51680 - cid:5 - Client connection closed: Client Closed[191036] 2024/02/21 08:05:24.881211 [DBG] 127.0.0.1:51694 - cid:6 - Client connection created[191036] 2024/02/21 08:05:24.883853 [DBG] 127.0.0.1:51694 - cid:6 - Client connection closed: Client Closed.[DEBUG] Server listening on port 4222 will stop.[191036] 2024/02/21 08:05:24.886733 [DBG] Trapped \"interrupt\" signal[191036] 2024/02/21 08:05:24.887181 [INF] Initiating Shutdown...[191036] 2024/02/21 08:05:24.887399 [DBG] Leafnode accept loop exiting..[191036] 2024/02/21 08:05:24.887673 [DBG] Client accept loop exiting..[191036] 2024/02/21 08:05:24.887699 [DBG] SYSTEM - System connection closed: Client Closed[191036] 2024/02/21 08:05:24.887990 [INF] Server Exiting..[DEBUG] Server listening on 4222 was stopped.=========================== 1 passed in 0.31s ==========================="},{"location":"#other-works","title":"Other works","text":"<ul> <li> <p>NATS Micro: An NATS micro framework in Python.</p> </li> <li> <p>NATS Request Many: A Python impementation of the Request Many pattern in NATS.</p> </li> <li> <p>NATS Connect Opts: An opinionated way to connect to NATS in Python.</p> </li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Guillaume Charbonnier</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Reference</li> <li>License</li> </ul>"},{"location":"reference/nats_contrib/test_server/","title":"Reference","text":""},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD","title":"<code>NATSD</code>","text":"Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>class NATSD:\n    def __init__(\n        self,\n        port: int = -1,\n        address: str | None = None,\n        client_advertise: str | None = None,\n        server_name: str | None = None,\n        server_tags: dict[str, str] | None = None,\n        user: str | None = None,\n        password: str | None = None,\n        users: list[dict[str, Any]] | None = None,\n        token: str | None = None,\n        http_port: int | None = None,\n        debug: bool | None = None,\n        trace: bool | None = None,\n        trace_verbose: bool | None = None,\n        logtime: bool | None = None,\n        pid_file: str | Path | None = None,\n        ports_file_dir: str | Path | None = None,\n        log_file: str | Path | None = None,\n        log_size_limit: int | None = None,\n        tls_cert: str | Path | None = None,\n        tls_key: str | Path | None = None,\n        tls_ca_cert: str | Path | None = None,\n        cluster_name: str | None = None,\n        cluster_url: str | None = None,\n        cluster_listen: str | None = None,\n        routes: list[str] | None = None,\n        no_advertise: bool | None = None,\n        with_jetstream: bool = False,\n        jetstream_domain: str | None = None,\n        store_directory: str | Path | None = None,\n        max_memory_store: int | None = None,\n        max_file_store: int | None = None,\n        max_outstanding_catchup: int | None = None,\n        leafnodes_listen_address: str | None = None,\n        leafnodes_listen_port: int | None = None,\n        leafnode_remotes: dict[str, Any] | None = None,\n        websocket_listen_address: str | None = None,\n        websocket_listen_port: int | None = None,\n        websocket_advertise_url: str | None = None,\n        websocket_tls_cert: str | Path | None = None,\n        websocket_tls_key: str | Path | None = None,\n        websocket_same_origin: bool | None = None,\n        websocket_allowed_origins: list[str] | None = None,\n        websocket_compression: bool | None = None,\n        jwt_path: str | Path | None = None,\n        operator: str | None = None,\n        system_account: str | None = None,\n        system_account_jwt: str | None = None,\n        allow_delete_jwt: bool | None = None,\n        resolver_preload: dict[str, str] | None = None,\n        config_file: str | Path | None = None,\n        max_cpus: float | None = None,\n        start_timeout: float = 2,\n        output_colorized: bool = True,\n        clean_log_file_on_exit: bool = False,\n        clean_pid_file_on_exit: bool = False,\n    ) -&gt; None:\n        \"\"\"Create a new instance of nats-server daemon.\n\n        Arguments:\n            address: host address nats-server should listen to. Default is 127.0.0.1 (localhost).\n            port: tcp port nats-server should listen to. Clients can connect to this port. Default is 4222.\n            server_name: the server name. Default to auto-generated name.\n            user: username required for connections. Omitted by default.\n            password: password required for connections. Omitted by default.\n            token: authorization token required for connections. Omitted by default.\n            http_port: port for http monitoring. Default is 8222.\n            debug: enable debugging output. Default is False.\n            trace: enable raw traces. Default is False.\n            pid_file: file to write process ID to. Omitted by default.\n            log_file: file to redirect log output to. Omitted by default.\n            tls_cert: server certificate file (TLS is enabled when both cert and key are provided)\n            tls_key: server key file (TLS is enabled when both cert and key are provided)\n            tls_ca_cert: client certificate for CA verification (mutual TLS is enabled when ca cert is provided)\n            cluster_name: the cluster name. Default to auto-generated name when clustering is enabled.\n            cluster_url: cluster URL for sollicited routes.\n            cluster_listen: cluster URL from which members can solicite routes. Enable cluster mode when set.\n            routes: routes to solicit and connect.\n            no_advertise: do not advertise known cluster information to clients.\n            with_jetstream: enable jetstream engine when True. Disabled by default.\n            store_directory: path to jetstream store directory. Default to a temporary directory.\n            config_file: path to a configuration file. None by default.\n            max_cpus: maximum number of CPU configured using GOMAXPROCS environment variable. By default all CPUs can be used.\n            start_timeout: amount of time to wait before raising an error when starting the daemon with wait=True.\n            output_colorized: enable colorized output. Default is True.\n        \"\"\"\n        self.output_writer = OutputWriter(colorized=output_colorized)\n        if config_file is None:\n            config_file = Path(tempfile.mkdtemp()).joinpath(\"nats.conf\")\n            generator = ConfigGenerator()\n            config_str = generator.render(\n                address=address,\n                port=port,\n                client_advertise=client_advertise,\n                server_name=server_name,\n                server_tags=server_tags,\n                user=user,\n                password=password,\n                users=users,\n                token=token,\n                http_port=http_port,\n                debug=debug,\n                trace=trace,\n                trace_verbose=trace_verbose,\n                log_time=logtime,\n                pid_file=pid_file,\n                ports_file_dir=ports_file_dir,\n                log_file=log_file,\n                log_size_limit=log_size_limit,\n                tls_cert=tls_cert,\n                tls_key=tls_key,\n                tls_ca_cert=tls_ca_cert,\n                cluster_name=cluster_name,\n                cluster_url=cluster_url,\n                cluster_listen=cluster_listen,\n                routes=routes,\n                no_advertise=no_advertise,\n                with_jetstream=with_jetstream,\n                jetstream_domain=jetstream_domain,\n                store_directory=store_directory,\n                max_memory_store=max_memory_store,\n                max_file_store=max_file_store,\n                max_outstanding_catchup=max_outstanding_catchup,\n                leafnodes_listen_address=leafnodes_listen_address,\n                leafnodes_listen_port=leafnodes_listen_port,\n                leafnode_remotes=leafnode_remotes,\n                websocket_listen_address=websocket_listen_address,\n                websocket_listen_port=websocket_listen_port,\n                websocket_advertise_url=websocket_advertise_url,\n                websocket_tls_cert=websocket_tls_cert,\n                websocket_tls_key=websocket_tls_key,\n                websocket_same_origin=websocket_same_origin,\n                websocket_allowed_origins=websocket_allowed_origins,\n                websocket_compression=websocket_compression,\n                jwt_path=jwt_path,\n                operator=operator,\n                system_account=system_account,\n                system_account_jwt=system_account_jwt,\n                allow_delete_jwt=allow_delete_jwt,\n                resolver_preload=resolver_preload,\n            )\n            config_file.write_text(config_str)\n            weakref.finalize(self, shutil.rmtree, config_file.parent, True)\n        self.server_name = server_name\n        self.address = address\n        self.port = port\n        self.user = user\n        self.password = password\n        self.timeout = start_timeout\n        self.http_port = http_port\n        self.token = token\n        self.bin_name = \"nats-server\"\n        self.bin_path: str | None = None\n        self.config_file = Path(config_file)\n        self.debug = debug or os.environ.get(\"DEBUG_NATS_TEST\", \"\") in (\n            \"true\",\n            \"1\",\n            \"y\",\n            \"yes\",\n            \"on\",\n        )\n        self.trace = trace or os.environ.get(\"DEBUG_NATS_TEST\", \"\") in (\n            \"true\",\n            \"1\",\n            \"y\",\n            \"yes\",\n            \"on\",\n        )\n        self.pid_file = Path(pid_file).absolute().as_posix() if pid_file else None\n        self.log_file = Path(log_file).absolute().as_posix() if log_file else None\n        self.max_cpus = max_cpus\n        self.clean_log_file_on_exit = clean_log_file_on_exit\n        self.clean_pid_file_on_exit = clean_pid_file_on_exit\n        self.tls_cert = tls_cert\n        self.tls_key = tls_key\n        self.tls_ca_cert = tls_ca_cert\n        if self.tls_ca_cert and self.tls_cert and self.tls_key:\n            self.tls_verify = True\n            self.tls = False\n        elif self.tls_cert and self.tls_key:\n            self.tls_verify = False\n            self.tls = True\n        elif self.tls_ca_cert:\n            raise ValueError(\n                \"Both certificate and key files must be provided with a CA certificate\"\n            )\n        elif self.tls_cert or self.tls_key:\n            raise ValueError(\"Both certificate and key files must be provided\")\n        else:\n            self.tls = False\n            self.tls_verify = False\n\n        self.cluster_name = cluster_name\n        self.cluster_url = cluster_url\n        self.cluster_listen = cluster_listen\n        self.routes = routes\n        self.no_advertise = no_advertise\n\n        self.jetstream_enabled = with_jetstream\n        if store_directory:\n            self.store_dir = Path(store_directory)\n            self._store_dir_is_temporary = False\n        else:\n            self.store_dir = Path(tempfile.mkdtemp()).resolve(True)\n            self._store_dir_is_temporary = True\n            weakref.finalize(self, shutil.rmtree, self.store_dir.as_posix(), True)\n\n        self.proc: subprocess.Popen[bytes] | None = None\n\n    def is_alive(self) -&gt; bool:\n        \"\"\"Check if the server is still running.\"\"\"\n        if self.proc is None:\n            return False\n        return self.proc.poll() is None\n\n    def _cleanup_on_exit(self) -&gt; None:\n        if self.proc and self.proc.poll() is None:\n            self.output_writer.warning(\n                \"Stopping server listening on port %d.\" % self.port\n            )\n            self.kill()\n        if self.clean_log_file_on_exit and self.log_file:\n            if Path(self.log_file).exists():\n                self.output_writer.warning(\n                    \"Removing log file {log_file}.\".format(log_file=self.log_file)\n                )\n                Path(self.log_file).unlink()\n        if self.clean_pid_file_on_exit and self.pid_file:\n            if Path(self.pid_file).exists():\n                self.output_writer.warning(\n                    \"Removing pid file {pid_file}.\".format(pid_file=self.pid_file)\n                )\n                Path(self.pid_file).unlink()\n\n    def start(self, wait: bool = False) -&gt; \"NATSD\":\n        \"\"\"Start the server listening on the given port.\n\n        By default this method will not wait for the server to be up and running.\n        If you want to wait for the server to be up and running, set the `wait` parameter to `True`.\n        \"\"\"\n        # Check if there is an nats-server binary in the current working directory\n        if Path(self.bin_name).is_file():\n            self.bin_path = Path(self.bin_name).resolve(True).as_posix()\n        # Path in `../scripts/install_nats.sh`\n        elif DEFAULT_BIN_DIR.joinpath(self.bin_name).is_file():\n            self.bin_path = DEFAULT_BIN_DIR.joinpath(self.bin_name).as_posix()\n        # This directory contains binary\n        else:\n            self.bin_path = shutil.which(self.bin_name)\n            if self.bin_path is None:\n                raise FileNotFoundError(\"nats-server executable not found\")\n        if self.debug:\n            self.output_writer.debug(f\"Using nats-server executable at {self.bin_path}\")\n        cmd = [\n            self.bin_path,\n        ]\n\n        if not self.config_file.exists():\n            raise FileNotFoundError(self.config_file)\n        else:\n            config_file = self.config_file.absolute().as_posix()\n        cmd.append(\"--config\")\n        cmd.append(config_file)\n\n        env = os.environ.copy()\n\n        if self.max_cpus:\n            env[\"GOMAXPROCS\"] = format(self.max_cpus, \".2f\")\n\n        if self.debug:\n            self.proc = subprocess.Popen(cmd, env=env)\n        else:\n            self.proc = subprocess.Popen(\n                cmd,\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n                env=env,\n            )\n\n        if self.debug:\n            self.output_writer.debug(\"Server listening on port %d started.\" % self.port)\n        if wait:\n            deadline = time.time() + self.timeout or float(\"inf\")\n            while True:\n                status = self.proc.poll()\n                if status is not None:\n                    if self.debug:\n                        self.output_writer.warning(\n                            \"Server listening on port {port} already finished running with exit {ret}\".format(\n                                port=self.port, ret=self.proc.returncode\n                            )\n                        )\n                    raise subprocess.CalledProcessError(\n                        returncode=self.proc.returncode, cmd=self.proc.args\n                    )\n                if time.time() &gt; deadline:\n                    self.stop()\n                    raise TimeoutError(\n                        f\"nats-server failed to start before timeout ({self.timeout:.3f}s)\"\n                    )\n                try:\n                    if try_open_port(self.address or \"localhost\", self.port):\n                        self.output_writer.debug(\n                            f\"Server listening on port {self.port} is up.\"\n                        )\n                        break\n                    else:\n                        self.output_writer.debug(\n                            f\"Waiting for server listening on port {self.port} to be up.\"\n                        )\n                except Exception as exc:\n                    self.output_writer.debug(\n                        f\"Waiting for server listening on port {self.port} to be up. Last error: {type(exc).__name__} - {repr(exc)}.\"\n                    )\n                time.sleep(0.1)\n                continue\n\n        weakref.finalize(self, self._cleanup_on_exit)\n        return self\n\n    def stop(self, timeout: float | None = 10) -&gt; None:\n        \"\"\"Stop the server listening on the given port.\n\n        This will first send a `SIGINT` signal to the process and wait for it to finish.\n        If the process does not finish within the given timeout, a `SIGKILL` signal will be sent.\n        \"\"\"\n        if self.debug:\n            self.output_writer.debug(f\"Server listening on port {self.port} will stop.\")\n\n        if self.proc is None:\n            if self.debug:\n                self.output_writer.warning(\n                    \"Failed terminating server listening on port %d\" % self.port\n                )\n\n        elif self.proc.returncode is not None and self.proc.returncode != 0:\n            if self.debug:\n                self.output_writer.warning(\n                    \"Server listening on port {port} already finished running with exit {ret}\".format(\n                        port=self.port, ret=self.proc.returncode\n                    )\n                )\n        else:\n            try:\n                self.cancel(timeout=timeout)\n            except TimeoutError:\n                self.kill()\n            if self.debug:\n                self.output_writer.debug(\n                    \"Server listening on %d was stopped.\" % self.port\n                )\n        if self.proc and self.proc.returncode != 0:\n            raise subprocess.CalledProcessError(\n                returncode=self.proc.returncode, cmd=self.proc.args\n            )\n\n    def wait(self, timeout: float | None = None) -&gt; int:\n        \"\"\"Wait for process to finish and return status code.\n\n        Possible status codes (non-exhaustive):\n\n        - -1: process is not started yet.\n        - 0: process has been stopped after entering lame duck mode or SIGINT signal.\n        - 15: process has been stopped due to TERM signal.\n        - 2: process has been stopped due to QUIT signal.\n        - -9: process has been stopped due to KILL signal.\n        \"\"\"\n        if self.proc is None:\n            return 0\n        status = self.proc.poll()\n        if status is not None:\n            return status\n        return self.proc.wait(timeout=timeout)\n\n    def quit(self, timeout: float | None = None) -&gt; None:\n        \"\"\"Send a `SIGQUIT` signal and wait for process to finish.\n\n        Note:\n            This method is only supported on Unix platforms.\n        \"\"\"\n        if not self.proc:\n            raise ProcessLookupError(\"Process is not started yet\")\n        self.proc.send_signal(signal.SIGQUIT)\n        self.wait(timeout=timeout)\n\n    def kill(self, timeout: float | None = None) -&gt; None:\n        \"\"\"Send a `SIGKILL` signal and wait for process to finish.\"\"\"\n        if not self.proc:\n            raise ProcessLookupError(\"Process is not started yet\")\n        self.proc.send_signal(signal.SIGKILL)\n        self.wait(timeout=timeout)\n\n    def cancel(self, timeout: float | None = 10) -&gt; None:\n        \"\"\"Send a `SIGINT` signal and wait for process to finish.\"\"\"\n        if not self.proc:\n            raise ProcessLookupError(\"Process is not started yet\")\n        self.proc.send_signal(signal.SIGINT)\n        self.wait(timeout=timeout)\n\n    def reopen_log_file(self) -&gt; None:\n        \"\"\"Send a `SIGUSR1` signal to reopen log file.\n\n        Note:\n            This method is only supported on Unix platforms.\n        \"\"\"\n        if not self.proc:\n            raise ProcessLookupError(\"Process is not started yet\")\n        self.proc.send_signal(signal.SIGUSR1)\n\n    def enter_lame_duck_mode(self) -&gt; None:\n        \"\"\"Send a `SIGUSR2` signal to enter lame duck mode.\n\n        Note:\n            This method is only supported on Unix platforms.\n        \"\"\"\n        if not self.proc:\n            raise ProcessLookupError(\"Process is not started yet\")\n        self.proc.send_signal(signal.SIGUSR2)\n\n    def reload_config(self) -&gt; None:\n        \"\"\"Send a `SIGHUP` signal to reload configuration file.\n\n        Note:\n            This method is only supported on Unix platforms.\n        \"\"\"\n        if not self.proc:\n            raise ProcessLookupError(\"Process is not started yet\")\n        self.proc.send_signal(signal.SIGHUP)\n\n    def __enter__(self) -&gt; \"NATSD\":\n        return self.start(wait=True)\n\n    def __exit__(\n        self,\n        error_type: type[BaseException] | None = None,\n        error: BaseException | None = None,\n        traceback: types.TracebackType | None = None,\n    ) -&gt; None:\n        self.stop()\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.__init__","title":"<code>__init__(port=-1, address=None, client_advertise=None, server_name=None, server_tags=None, user=None, password=None, users=None, token=None, http_port=None, debug=None, trace=None, trace_verbose=None, logtime=None, pid_file=None, ports_file_dir=None, log_file=None, log_size_limit=None, tls_cert=None, tls_key=None, tls_ca_cert=None, cluster_name=None, cluster_url=None, cluster_listen=None, routes=None, no_advertise=None, with_jetstream=False, jetstream_domain=None, store_directory=None, max_memory_store=None, max_file_store=None, max_outstanding_catchup=None, leafnodes_listen_address=None, leafnodes_listen_port=None, leafnode_remotes=None, websocket_listen_address=None, websocket_listen_port=None, websocket_advertise_url=None, websocket_tls_cert=None, websocket_tls_key=None, websocket_same_origin=None, websocket_allowed_origins=None, websocket_compression=None, jwt_path=None, operator=None, system_account=None, system_account_jwt=None, allow_delete_jwt=None, resolver_preload=None, config_file=None, max_cpus=None, start_timeout=2, output_colorized=True, clean_log_file_on_exit=False, clean_pid_file_on_exit=False)</code>","text":"<p>Create a new instance of nats-server daemon.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str | None</code> <p>host address nats-server should listen to. Default is 127.0.0.1 (localhost).</p> <code>None</code> <code>port</code> <code>int</code> <p>tcp port nats-server should listen to. Clients can connect to this port. Default is 4222.</p> <code>-1</code> <code>server_name</code> <code>str | None</code> <p>the server name. Default to auto-generated name.</p> <code>None</code> <code>user</code> <code>str | None</code> <p>username required for connections. Omitted by default.</p> <code>None</code> <code>password</code> <code>str | None</code> <p>password required for connections. Omitted by default.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>authorization token required for connections. Omitted by default.</p> <code>None</code> <code>http_port</code> <code>int | None</code> <p>port for http monitoring. Default is 8222.</p> <code>None</code> <code>debug</code> <code>bool | None</code> <p>enable debugging output. Default is False.</p> <code>None</code> <code>trace</code> <code>bool | None</code> <p>enable raw traces. Default is False.</p> <code>None</code> <code>pid_file</code> <code>str | Path | None</code> <p>file to write process ID to. Omitted by default.</p> <code>None</code> <code>log_file</code> <code>str | Path | None</code> <p>file to redirect log output to. Omitted by default.</p> <code>None</code> <code>tls_cert</code> <code>str | Path | None</code> <p>server certificate file (TLS is enabled when both cert and key are provided)</p> <code>None</code> <code>tls_key</code> <code>str | Path | None</code> <p>server key file (TLS is enabled when both cert and key are provided)</p> <code>None</code> <code>tls_ca_cert</code> <code>str | Path | None</code> <p>client certificate for CA verification (mutual TLS is enabled when ca cert is provided)</p> <code>None</code> <code>cluster_name</code> <code>str | None</code> <p>the cluster name. Default to auto-generated name when clustering is enabled.</p> <code>None</code> <code>cluster_url</code> <code>str | None</code> <p>cluster URL for sollicited routes.</p> <code>None</code> <code>cluster_listen</code> <code>str | None</code> <p>cluster URL from which members can solicite routes. Enable cluster mode when set.</p> <code>None</code> <code>routes</code> <code>list[str] | None</code> <p>routes to solicit and connect.</p> <code>None</code> <code>no_advertise</code> <code>bool | None</code> <p>do not advertise known cluster information to clients.</p> <code>None</code> <code>with_jetstream</code> <code>bool</code> <p>enable jetstream engine when True. Disabled by default.</p> <code>False</code> <code>store_directory</code> <code>str | Path | None</code> <p>path to jetstream store directory. Default to a temporary directory.</p> <code>None</code> <code>config_file</code> <code>str | Path | None</code> <p>path to a configuration file. None by default.</p> <code>None</code> <code>max_cpus</code> <code>float | None</code> <p>maximum number of CPU configured using GOMAXPROCS environment variable. By default all CPUs can be used.</p> <code>None</code> <code>start_timeout</code> <code>float</code> <p>amount of time to wait before raising an error when starting the daemon with wait=True.</p> <code>2</code> <code>output_colorized</code> <code>bool</code> <p>enable colorized output. Default is True.</p> <code>True</code> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def __init__(\n    self,\n    port: int = -1,\n    address: str | None = None,\n    client_advertise: str | None = None,\n    server_name: str | None = None,\n    server_tags: dict[str, str] | None = None,\n    user: str | None = None,\n    password: str | None = None,\n    users: list[dict[str, Any]] | None = None,\n    token: str | None = None,\n    http_port: int | None = None,\n    debug: bool | None = None,\n    trace: bool | None = None,\n    trace_verbose: bool | None = None,\n    logtime: bool | None = None,\n    pid_file: str | Path | None = None,\n    ports_file_dir: str | Path | None = None,\n    log_file: str | Path | None = None,\n    log_size_limit: int | None = None,\n    tls_cert: str | Path | None = None,\n    tls_key: str | Path | None = None,\n    tls_ca_cert: str | Path | None = None,\n    cluster_name: str | None = None,\n    cluster_url: str | None = None,\n    cluster_listen: str | None = None,\n    routes: list[str] | None = None,\n    no_advertise: bool | None = None,\n    with_jetstream: bool = False,\n    jetstream_domain: str | None = None,\n    store_directory: str | Path | None = None,\n    max_memory_store: int | None = None,\n    max_file_store: int | None = None,\n    max_outstanding_catchup: int | None = None,\n    leafnodes_listen_address: str | None = None,\n    leafnodes_listen_port: int | None = None,\n    leafnode_remotes: dict[str, Any] | None = None,\n    websocket_listen_address: str | None = None,\n    websocket_listen_port: int | None = None,\n    websocket_advertise_url: str | None = None,\n    websocket_tls_cert: str | Path | None = None,\n    websocket_tls_key: str | Path | None = None,\n    websocket_same_origin: bool | None = None,\n    websocket_allowed_origins: list[str] | None = None,\n    websocket_compression: bool | None = None,\n    jwt_path: str | Path | None = None,\n    operator: str | None = None,\n    system_account: str | None = None,\n    system_account_jwt: str | None = None,\n    allow_delete_jwt: bool | None = None,\n    resolver_preload: dict[str, str] | None = None,\n    config_file: str | Path | None = None,\n    max_cpus: float | None = None,\n    start_timeout: float = 2,\n    output_colorized: bool = True,\n    clean_log_file_on_exit: bool = False,\n    clean_pid_file_on_exit: bool = False,\n) -&gt; None:\n    \"\"\"Create a new instance of nats-server daemon.\n\n    Arguments:\n        address: host address nats-server should listen to. Default is 127.0.0.1 (localhost).\n        port: tcp port nats-server should listen to. Clients can connect to this port. Default is 4222.\n        server_name: the server name. Default to auto-generated name.\n        user: username required for connections. Omitted by default.\n        password: password required for connections. Omitted by default.\n        token: authorization token required for connections. Omitted by default.\n        http_port: port for http monitoring. Default is 8222.\n        debug: enable debugging output. Default is False.\n        trace: enable raw traces. Default is False.\n        pid_file: file to write process ID to. Omitted by default.\n        log_file: file to redirect log output to. Omitted by default.\n        tls_cert: server certificate file (TLS is enabled when both cert and key are provided)\n        tls_key: server key file (TLS is enabled when both cert and key are provided)\n        tls_ca_cert: client certificate for CA verification (mutual TLS is enabled when ca cert is provided)\n        cluster_name: the cluster name. Default to auto-generated name when clustering is enabled.\n        cluster_url: cluster URL for sollicited routes.\n        cluster_listen: cluster URL from which members can solicite routes. Enable cluster mode when set.\n        routes: routes to solicit and connect.\n        no_advertise: do not advertise known cluster information to clients.\n        with_jetstream: enable jetstream engine when True. Disabled by default.\n        store_directory: path to jetstream store directory. Default to a temporary directory.\n        config_file: path to a configuration file. None by default.\n        max_cpus: maximum number of CPU configured using GOMAXPROCS environment variable. By default all CPUs can be used.\n        start_timeout: amount of time to wait before raising an error when starting the daemon with wait=True.\n        output_colorized: enable colorized output. Default is True.\n    \"\"\"\n    self.output_writer = OutputWriter(colorized=output_colorized)\n    if config_file is None:\n        config_file = Path(tempfile.mkdtemp()).joinpath(\"nats.conf\")\n        generator = ConfigGenerator()\n        config_str = generator.render(\n            address=address,\n            port=port,\n            client_advertise=client_advertise,\n            server_name=server_name,\n            server_tags=server_tags,\n            user=user,\n            password=password,\n            users=users,\n            token=token,\n            http_port=http_port,\n            debug=debug,\n            trace=trace,\n            trace_verbose=trace_verbose,\n            log_time=logtime,\n            pid_file=pid_file,\n            ports_file_dir=ports_file_dir,\n            log_file=log_file,\n            log_size_limit=log_size_limit,\n            tls_cert=tls_cert,\n            tls_key=tls_key,\n            tls_ca_cert=tls_ca_cert,\n            cluster_name=cluster_name,\n            cluster_url=cluster_url,\n            cluster_listen=cluster_listen,\n            routes=routes,\n            no_advertise=no_advertise,\n            with_jetstream=with_jetstream,\n            jetstream_domain=jetstream_domain,\n            store_directory=store_directory,\n            max_memory_store=max_memory_store,\n            max_file_store=max_file_store,\n            max_outstanding_catchup=max_outstanding_catchup,\n            leafnodes_listen_address=leafnodes_listen_address,\n            leafnodes_listen_port=leafnodes_listen_port,\n            leafnode_remotes=leafnode_remotes,\n            websocket_listen_address=websocket_listen_address,\n            websocket_listen_port=websocket_listen_port,\n            websocket_advertise_url=websocket_advertise_url,\n            websocket_tls_cert=websocket_tls_cert,\n            websocket_tls_key=websocket_tls_key,\n            websocket_same_origin=websocket_same_origin,\n            websocket_allowed_origins=websocket_allowed_origins,\n            websocket_compression=websocket_compression,\n            jwt_path=jwt_path,\n            operator=operator,\n            system_account=system_account,\n            system_account_jwt=system_account_jwt,\n            allow_delete_jwt=allow_delete_jwt,\n            resolver_preload=resolver_preload,\n        )\n        config_file.write_text(config_str)\n        weakref.finalize(self, shutil.rmtree, config_file.parent, True)\n    self.server_name = server_name\n    self.address = address\n    self.port = port\n    self.user = user\n    self.password = password\n    self.timeout = start_timeout\n    self.http_port = http_port\n    self.token = token\n    self.bin_name = \"nats-server\"\n    self.bin_path: str | None = None\n    self.config_file = Path(config_file)\n    self.debug = debug or os.environ.get(\"DEBUG_NATS_TEST\", \"\") in (\n        \"true\",\n        \"1\",\n        \"y\",\n        \"yes\",\n        \"on\",\n    )\n    self.trace = trace or os.environ.get(\"DEBUG_NATS_TEST\", \"\") in (\n        \"true\",\n        \"1\",\n        \"y\",\n        \"yes\",\n        \"on\",\n    )\n    self.pid_file = Path(pid_file).absolute().as_posix() if pid_file else None\n    self.log_file = Path(log_file).absolute().as_posix() if log_file else None\n    self.max_cpus = max_cpus\n    self.clean_log_file_on_exit = clean_log_file_on_exit\n    self.clean_pid_file_on_exit = clean_pid_file_on_exit\n    self.tls_cert = tls_cert\n    self.tls_key = tls_key\n    self.tls_ca_cert = tls_ca_cert\n    if self.tls_ca_cert and self.tls_cert and self.tls_key:\n        self.tls_verify = True\n        self.tls = False\n    elif self.tls_cert and self.tls_key:\n        self.tls_verify = False\n        self.tls = True\n    elif self.tls_ca_cert:\n        raise ValueError(\n            \"Both certificate and key files must be provided with a CA certificate\"\n        )\n    elif self.tls_cert or self.tls_key:\n        raise ValueError(\"Both certificate and key files must be provided\")\n    else:\n        self.tls = False\n        self.tls_verify = False\n\n    self.cluster_name = cluster_name\n    self.cluster_url = cluster_url\n    self.cluster_listen = cluster_listen\n    self.routes = routes\n    self.no_advertise = no_advertise\n\n    self.jetstream_enabled = with_jetstream\n    if store_directory:\n        self.store_dir = Path(store_directory)\n        self._store_dir_is_temporary = False\n    else:\n        self.store_dir = Path(tempfile.mkdtemp()).resolve(True)\n        self._store_dir_is_temporary = True\n        weakref.finalize(self, shutil.rmtree, self.store_dir.as_posix(), True)\n\n    self.proc: subprocess.Popen[bytes] | None = None\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.cancel","title":"<code>cancel(timeout=10)</code>","text":"<p>Send a <code>SIGINT</code> signal and wait for process to finish.</p> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def cancel(self, timeout: float | None = 10) -&gt; None:\n    \"\"\"Send a `SIGINT` signal and wait for process to finish.\"\"\"\n    if not self.proc:\n        raise ProcessLookupError(\"Process is not started yet\")\n    self.proc.send_signal(signal.SIGINT)\n    self.wait(timeout=timeout)\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.enter_lame_duck_mode","title":"<code>enter_lame_duck_mode()</code>","text":"<p>Send a <code>SIGUSR2</code> signal to enter lame duck mode.</p> Note <p>This method is only supported on Unix platforms.</p> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def enter_lame_duck_mode(self) -&gt; None:\n    \"\"\"Send a `SIGUSR2` signal to enter lame duck mode.\n\n    Note:\n        This method is only supported on Unix platforms.\n    \"\"\"\n    if not self.proc:\n        raise ProcessLookupError(\"Process is not started yet\")\n    self.proc.send_signal(signal.SIGUSR2)\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.is_alive","title":"<code>is_alive()</code>","text":"<p>Check if the server is still running.</p> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def is_alive(self) -&gt; bool:\n    \"\"\"Check if the server is still running.\"\"\"\n    if self.proc is None:\n        return False\n    return self.proc.poll() is None\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.kill","title":"<code>kill(timeout=None)</code>","text":"<p>Send a <code>SIGKILL</code> signal and wait for process to finish.</p> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def kill(self, timeout: float | None = None) -&gt; None:\n    \"\"\"Send a `SIGKILL` signal and wait for process to finish.\"\"\"\n    if not self.proc:\n        raise ProcessLookupError(\"Process is not started yet\")\n    self.proc.send_signal(signal.SIGKILL)\n    self.wait(timeout=timeout)\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.quit","title":"<code>quit(timeout=None)</code>","text":"<p>Send a <code>SIGQUIT</code> signal and wait for process to finish.</p> Note <p>This method is only supported on Unix platforms.</p> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def quit(self, timeout: float | None = None) -&gt; None:\n    \"\"\"Send a `SIGQUIT` signal and wait for process to finish.\n\n    Note:\n        This method is only supported on Unix platforms.\n    \"\"\"\n    if not self.proc:\n        raise ProcessLookupError(\"Process is not started yet\")\n    self.proc.send_signal(signal.SIGQUIT)\n    self.wait(timeout=timeout)\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.reload_config","title":"<code>reload_config()</code>","text":"<p>Send a <code>SIGHUP</code> signal to reload configuration file.</p> Note <p>This method is only supported on Unix platforms.</p> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def reload_config(self) -&gt; None:\n    \"\"\"Send a `SIGHUP` signal to reload configuration file.\n\n    Note:\n        This method is only supported on Unix platforms.\n    \"\"\"\n    if not self.proc:\n        raise ProcessLookupError(\"Process is not started yet\")\n    self.proc.send_signal(signal.SIGHUP)\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.reopen_log_file","title":"<code>reopen_log_file()</code>","text":"<p>Send a <code>SIGUSR1</code> signal to reopen log file.</p> Note <p>This method is only supported on Unix platforms.</p> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def reopen_log_file(self) -&gt; None:\n    \"\"\"Send a `SIGUSR1` signal to reopen log file.\n\n    Note:\n        This method is only supported on Unix platforms.\n    \"\"\"\n    if not self.proc:\n        raise ProcessLookupError(\"Process is not started yet\")\n    self.proc.send_signal(signal.SIGUSR1)\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.start","title":"<code>start(wait=False)</code>","text":"<p>Start the server listening on the given port.</p> <p>By default this method will not wait for the server to be up and running. If you want to wait for the server to be up and running, set the <code>wait</code> parameter to <code>True</code>.</p> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def start(self, wait: bool = False) -&gt; \"NATSD\":\n    \"\"\"Start the server listening on the given port.\n\n    By default this method will not wait for the server to be up and running.\n    If you want to wait for the server to be up and running, set the `wait` parameter to `True`.\n    \"\"\"\n    # Check if there is an nats-server binary in the current working directory\n    if Path(self.bin_name).is_file():\n        self.bin_path = Path(self.bin_name).resolve(True).as_posix()\n    # Path in `../scripts/install_nats.sh`\n    elif DEFAULT_BIN_DIR.joinpath(self.bin_name).is_file():\n        self.bin_path = DEFAULT_BIN_DIR.joinpath(self.bin_name).as_posix()\n    # This directory contains binary\n    else:\n        self.bin_path = shutil.which(self.bin_name)\n        if self.bin_path is None:\n            raise FileNotFoundError(\"nats-server executable not found\")\n    if self.debug:\n        self.output_writer.debug(f\"Using nats-server executable at {self.bin_path}\")\n    cmd = [\n        self.bin_path,\n    ]\n\n    if not self.config_file.exists():\n        raise FileNotFoundError(self.config_file)\n    else:\n        config_file = self.config_file.absolute().as_posix()\n    cmd.append(\"--config\")\n    cmd.append(config_file)\n\n    env = os.environ.copy()\n\n    if self.max_cpus:\n        env[\"GOMAXPROCS\"] = format(self.max_cpus, \".2f\")\n\n    if self.debug:\n        self.proc = subprocess.Popen(cmd, env=env)\n    else:\n        self.proc = subprocess.Popen(\n            cmd,\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            env=env,\n        )\n\n    if self.debug:\n        self.output_writer.debug(\"Server listening on port %d started.\" % self.port)\n    if wait:\n        deadline = time.time() + self.timeout or float(\"inf\")\n        while True:\n            status = self.proc.poll()\n            if status is not None:\n                if self.debug:\n                    self.output_writer.warning(\n                        \"Server listening on port {port} already finished running with exit {ret}\".format(\n                            port=self.port, ret=self.proc.returncode\n                        )\n                    )\n                raise subprocess.CalledProcessError(\n                    returncode=self.proc.returncode, cmd=self.proc.args\n                )\n            if time.time() &gt; deadline:\n                self.stop()\n                raise TimeoutError(\n                    f\"nats-server failed to start before timeout ({self.timeout:.3f}s)\"\n                )\n            try:\n                if try_open_port(self.address or \"localhost\", self.port):\n                    self.output_writer.debug(\n                        f\"Server listening on port {self.port} is up.\"\n                    )\n                    break\n                else:\n                    self.output_writer.debug(\n                        f\"Waiting for server listening on port {self.port} to be up.\"\n                    )\n            except Exception as exc:\n                self.output_writer.debug(\n                    f\"Waiting for server listening on port {self.port} to be up. Last error: {type(exc).__name__} - {repr(exc)}.\"\n                )\n            time.sleep(0.1)\n            continue\n\n    weakref.finalize(self, self._cleanup_on_exit)\n    return self\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.stop","title":"<code>stop(timeout=10)</code>","text":"<p>Stop the server listening on the given port.</p> <p>This will first send a <code>SIGINT</code> signal to the process and wait for it to finish. If the process does not finish within the given timeout, a <code>SIGKILL</code> signal will be sent.</p> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def stop(self, timeout: float | None = 10) -&gt; None:\n    \"\"\"Stop the server listening on the given port.\n\n    This will first send a `SIGINT` signal to the process and wait for it to finish.\n    If the process does not finish within the given timeout, a `SIGKILL` signal will be sent.\n    \"\"\"\n    if self.debug:\n        self.output_writer.debug(f\"Server listening on port {self.port} will stop.\")\n\n    if self.proc is None:\n        if self.debug:\n            self.output_writer.warning(\n                \"Failed terminating server listening on port %d\" % self.port\n            )\n\n    elif self.proc.returncode is not None and self.proc.returncode != 0:\n        if self.debug:\n            self.output_writer.warning(\n                \"Server listening on port {port} already finished running with exit {ret}\".format(\n                    port=self.port, ret=self.proc.returncode\n                )\n            )\n    else:\n        try:\n            self.cancel(timeout=timeout)\n        except TimeoutError:\n            self.kill()\n        if self.debug:\n            self.output_writer.debug(\n                \"Server listening on %d was stopped.\" % self.port\n            )\n    if self.proc and self.proc.returncode != 0:\n        raise subprocess.CalledProcessError(\n            returncode=self.proc.returncode, cmd=self.proc.args\n        )\n</code></pre>"},{"location":"reference/nats_contrib/test_server/#nats_contrib.test_server.NATSD.wait","title":"<code>wait(timeout=None)</code>","text":"<p>Wait for process to finish and return status code.</p> <p>Possible status codes (non-exhaustive):</p> <ul> <li>-1: process is not started yet.</li> <li>0: process has been stopped after entering lame duck mode or SIGINT signal.</li> <li>15: process has been stopped due to TERM signal.</li> <li>2: process has been stopped due to QUIT signal.</li> <li>-9: process has been stopped due to KILL signal.</li> </ul> Source code in <code>src/nats_contrib/test_server/natsd.py</code> <pre><code>def wait(self, timeout: float | None = None) -&gt; int:\n    \"\"\"Wait for process to finish and return status code.\n\n    Possible status codes (non-exhaustive):\n\n    - -1: process is not started yet.\n    - 0: process has been stopped after entering lame duck mode or SIGINT signal.\n    - 15: process has been stopped due to TERM signal.\n    - 2: process has been stopped due to QUIT signal.\n    - -9: process has been stopped due to KILL signal.\n    \"\"\"\n    if self.proc is None:\n        return 0\n    status = self.proc.poll()\n    if status is not None:\n        return status\n    return self.proc.wait(timeout=timeout)\n</code></pre>"}]}